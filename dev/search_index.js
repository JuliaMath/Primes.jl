var documenterSearchIndex = {"docs":
[{"location":"api/#Prime-number-functions","page":"Functions","title":"Prime number functions","text":"","category":"section"},{"location":"api/#Prime-factorization","page":"Functions","title":"Prime factorization","text":"","category":"section"},{"location":"api/#Generating-prime-numbers","page":"Functions","title":"Generating prime numbers","text":"","category":"section"},{"location":"api/#Identifying-prime-numbers","page":"Functions","title":"Identifying prime numbers","text":"","category":"section"},{"location":"api/#Number-theoretic-functions","page":"Functions","title":"Number-theoretic functions","text":"","category":"section"},{"location":"api/#Primes.eachfactor","page":"Functions","title":"Primes.eachfactor","text":"eachfactor(n::Integer)->FactorIterator\n\nReturns a lazy iterator of factors of n in (factor, multiplicity) pairs. This can be very useful for computing multiplicative functions since for small numbers (e.g. numbers with no factor >2^16), allocating the storage required for factor(n) can introduce significant overhead.\n\n\n\n\n\n","category":"function"},{"location":"api/#Primes.factor","page":"Functions","title":"Primes.factor","text":"factor(n::Integer) -> Primes.Factorization\n\nCompute the prime factorization of an integer n. The returned object, of type Factorization, is an associative container whose keys correspond to the factors, in sorted order. The value associated with each key indicates the multiplicity (i.e. the number of times the factor appears in the factorization).\n\njulia> factor(100)\n2^2 ⋅ 5^2\n\nFor convenience, a negative number n is factored as -1*(-n) (i.e. -1 is considered to be a factor), and 0 is factored as 0^1:\n\njulia> factor(-9)\n-1 ⋅ 3^2\n\njulia> factor(0)\n0\n\njulia> collect(factor(0))\n1-element Array{Pair{Int64,Int64},1}:\n 0=>1\n\n\n\n\n\nfactor(ContainerType, n::Integer) -> ContainerType\n\nReturn the factorization of n stored in a ContainerType, which must be a subtype of AbstractDict or AbstractArray, a Set, or an BitSet.\n\njulia> factor(DataStructures.SortedDict, 100)\nDataStructures.SortedDict{Int64,Int64,Base.Order.ForwardOrdering} with 2 entries:\n  2 => 2\n  5 => 2\n\nWhen ContainerType <: AbstractArray, this returns the list of all prime factors of n with multiplicities, in sorted order.\n\njulia> factor(Vector, 100)\n4-element Array{Int64,1}:\n 2\n 2\n 5\n 5\n\njulia> prod(factor(Vector, 100)) == 100\ntrue\n\nWhen ContainerType == Set, this returns the distinct prime factors as a set.\n\njulia> factor(Set, 100)\nSet([2,5])\n\n\n\n\n\n","category":"function"},{"location":"api/#Primes.prodfactors","page":"Functions","title":"Primes.prodfactors","text":"prodfactors(factors)\n\nCompute n (or the radical of n when factors is of type Set or BitSet) where factors is interpreted as the result of factor(typeof(factors), n). Note that if factors is of type AbstractArray or Primes.Factorization, then prodfactors is equivalent to Base.prod.\n\njulia> prodfactors(factor(100))\n100\n\n\n\n\n\n","category":"function"},{"location":"api/#Primes.primes","page":"Functions","title":"Primes.primes","text":"primes([lo,] hi)\n\nReturns a collection of the prime numbers (from lo, if specified) up to hi.\n\n\n\n\n\n","category":"function"},{"location":"api/#Primes.nextprime","page":"Functions","title":"Primes.nextprime","text":"nextprime(n::Integer, i::Integer=1; interval::Integer=1)\n\nThe i-th smallest prime not less than n (in particular, nextprime(p) == p if p is prime). If i < 0, this is equivalent to prevprime(n, -i). Note that for n::BigInt, the returned number is only a pseudo-prime (the function isprime is used internally). See also prevprime.\n\nIf interval is provided, primes are sought in increments of interval. This can be useful to ensure the presence of certain divisors in p-1. The range of possible values for interval is currently 1:typemax(Int).\n\njulia> nextprime(4)\n5\n\njulia> nextprime(5)\n5\n\njulia> nextprime(4, 2)\n7\n\njulia> nextprime(5, 2)\n7\n\njulia> nextprime(2^10+1; interval=1024)\n12289\n\njulia> gcd(12289 - 1, 1024) # 1024 | p - 1\n1024\n\n\n\n\n\n","category":"function"},{"location":"api/#Primes.prevprime","page":"Functions","title":"Primes.prevprime","text":"prevprime(n::Integer, i::Integer=1; interval::Integer=1)\n\nThe i-th largest prime not greater than n (in particular prevprime(p) == p if p is prime). If i < 0, this is equivalent to nextprime(n, -i). Note that for n::BigInt, the returned number is only a pseudo-prime (the function isprime is used internally). See also nextprime.\n\nIf interval is provided, primes are sought in increments of interval. This can be useful to ensure the presence of certain divisors in p-1. The range of possible values for interval is currently 1:typemax(Int).\n\njulia> prevprime(4)\n3\n\njulia> prevprime(5)\n5\n\njulia> prevprime(5, 2)\n3\n\n\n\n\n\n","category":"function"},{"location":"api/#Primes.prime","page":"Functions","title":"Primes.prime","text":"prime(::Type{<:Integer}=Int, i::Integer)\n\nThe i-th prime number.\n\njulia> prime(1)\n2\n\njulia> prime(3)\n5\n\n\n\n\n\n\n","category":"function"},{"location":"api/#Primes.isprime","page":"Functions","title":"Primes.isprime","text":"isprime(n::Integer) -> Bool\n\nReturns for values in the range of an INT64 variable:  true if n is prime, and false otherwise for bigger values: true if n is probably prime, and false otherwise (false-positive rate = 0.25^reps with reps=25 –> considered safe)\n\nMore detailed:\n\nfor even numbers: returns deterministic and correct results regardless of type\nfor values in the range of an Int64 variable: returns deterministic and correct results (by Lookup-tables, trial-division, Miller-Rabin, Lucas-Test)\nfor bigger values: returns probabilistic results from GNU Multiple Precision Arithmetic Library\n\njulia> isprime(3)\ntrue\n\njulia> isprime(4)\nfalse\n\n\n\n\n\nisprime(x::BigInt, [reps = 25]) -> Bool\n\nProbabilistic primality test. Returns true if x is prime with high probability (pseudoprime); and false if x is composite (not prime). The false positive rate is about 0.25^reps. reps = 25 is considered safe for cryptographic applications (Knuth, Seminumerical Algorithms).\n\nisprobablyprime is inherited from the module IntegerMathUtils that provides a wrapper to access functionality from the  GNU Multiple Precision Arithmetic Library (GMP) library\n\njulia> isprime(big(3))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Primes.ismersenneprime","page":"Functions","title":"Primes.ismersenneprime","text":"ismersenneprime(M::Integer; [check::Bool = true]) -> Bool\n\nLucas-Lehmer deterministic test for Mersenne primes. M must be a Mersenne number, i.e. of the form M = 2^p - 1, where p is a prime number. Use the keyword argument check to enable/disable checking whether M is a valid Mersenne number; to be used with caution. Return true if the given Mersenne number is prime, and false otherwise.\n\njulia> ismersenneprime(2^11 - 1)\nfalse\n\njulia> ismersenneprime(2^13 - 1)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Primes.primesmask","page":"Functions","title":"Primes.primesmask","text":"primesmask([lo,] hi)\n\nReturns a prime sieve, as a BitArray, of the positive integers (from lo, if specified) up to hi. Useful when working with either primes or composite numbers.\n\n\n\n\n\n","category":"function"},{"location":"api/#Primes.radical","page":"Functions","title":"Primes.radical","text":"radical(n::Integer)\n\nCompute the radical of n, i.e. the largest square-free divisor of n. This is equal to the product of the distinct prime numbers dividing n.\n\njulia> radical(2*2*3)\n6\n\n\n\n\n\n","category":"function"},{"location":"api/#Primes.totient","page":"Functions","title":"Primes.totient","text":"totient(f::Factorization{T}) -> T\n\nCompute the Euler totient function of the number whose prime factorization is given by f. This method may be preferable to totient(::Integer) when the factorization can be reused for other purposes.\n\n\n\n\n\ntotient(n::Integer) -> Integer\n\nCompute the Euler totient function ϕ(n), which counts the number of positive integers less than or equal to n that are relatively prime to n (that is, the number of positive integers m ≤ n with gcd(m, n) == 1). The totient function of n when n is negative is defined to be totient(abs(n)).\n\n\n\n\n\n","category":"function"},{"location":"api/#Primes.divisors","page":"Functions","title":"Primes.divisors","text":"divisors(n::Integer) -> Vector\n\nReturn a vector with the positive divisors of n.\n\nFor a nonzero integer n with prime factorization n = p₁^k₁ ⋯ pₘ^kₘ, divisors(n) returns a vector of length (k₁ + 1)⋯(kₘ + 1) containing the divisors of n in lexicographic (rather than numerical) order.\n\ndivisors(-n) is equivalent to divisors(n).\n\nFor convenience, divisors(0) returns [].\n\nExample\n\njulia> divisors(60)\n12-element Vector{Int64}:\n  1         # 1\n  2         # 2\n  4         # 2 * 2\n  3         # 3\n  6         # 3 * 2\n 12         # 3 * 2 * 2\n  5         # 5\n 10         # 5 * 2\n 20         # 5 * 2 * 2\n 15         # 5 * 3\n 30         # 5 * 3 * 2\n 60         # 5 * 3 * 2 * 2\n\njulia> divisors(-10)\n4-element Vector{Int64}:\n  1\n  2\n  5\n 10\n\njulia> divisors(0)\nInt64[]\n\n\n\n\n\ndivisors(f::Factorization) -> Vector\n\nReturn a vector with the positive divisors of the number whose factorization is f. Divisors are sorted lexicographically, rather than numerically.\n\n\n\n\n\n","category":"function"},{"location":"#Primes.jl","page":"Home","title":"Primes.jl","text":"This package provides functions for computing prime numbers in Julia.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"This release is available for Julia versions 1.6 and up.\n\nTo install it, run\n\nusing Pkg ; Pkg.add(\"Primes\")\n\nfrom the Julia REPL.","category":"section"}]
}
